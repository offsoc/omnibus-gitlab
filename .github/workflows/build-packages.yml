name: Build GitLab EE Packages

on:
  push:
    branches: [ main, master ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      debug:
        description: 'Enable debug mode'
        required: false
        default: false
        type: boolean
  schedule:
    - cron: '0 2 * * 1'  # Weekly builds on Mondays at 2 AM UTC

jobs:
  build-packages:
    runs-on: ubuntu-22.04
    strategy:
      matrix:
        include:
          - os: ubuntu20
            image: ubuntu:20.04
          - os: ubuntu22
            image: ubuntu:22.04
          - os: debian11
            image: debian:bullseye
          - os: debian12
            image: debian:bookworm
      fail-fast: false
      max-parallel: 2
    env:
      ee: "true"
      COMPRESS_XZ: "true"
      GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
      BUNDLE_JOBS: "4"
      BUNDLE_RETRY: "3"
      BUILD_LOG_LEVEL: ${{ inputs.debug && 'debug' || 'info' }}
      DEBUG: ${{ inputs.debug && 'true' || 'false' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false
          
      - name: System diagnostics
        run: |
          echo "=== System Information ==="
          echo "Runner OS: $(uname -a)"
          echo "Date: $(date)"
          echo "Working directory: $(pwd)"
          echo "User: $(whoami)"
          echo "\n=== Disk Space ==="
          df -h
          echo "\n=== Memory ==="
          free -h
          echo "\n=== CPU ==="
          lscpu | head -10
          
          # Suppress apt cleanup errors that occur during runner shutdown
          echo "Note: Some permission errors during runner cleanup are normal and harmless"
          
          if [[ "${{ env.DEBUG }}" == "true" ]]; then
            echo "\n=== Environment Variables ==="
            env | sort
          fi

      - name: Setup environment
        run: |
          # Create cache directories with proper permissions
          mkdir -p $HOME/.cache/omnibus $HOME/pkg $HOME/.bundle
          chmod 755 $HOME/.cache/omnibus
          # Set environment variables
          echo "OMNIBUS_CACHE_DIR=$HOME/.cache/omnibus" >> $GITHUB_ENV
          echo "PKG_DIR=$HOME/pkg" >> $GITHUB_ENV

      - name: Install system dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends \
            build-essential \
            ruby ruby-dev \
            libssl-dev zlib1g-dev \
            libffi-dev libreadline-dev libyaml-dev \
            libxml2-dev libxslt1-dev \
            libpq-dev libsqlite3-dev libmysqlclient-dev \
            libcurl4-openssl-dev libicu-dev \
            cmake pkg-config \
            xz-utils curl git ca-certificates \
            rpm fakeroot
          # Clean up apt cache (requires sudo)
          sudo apt-get clean
          sudo rm -rf /var/lib/apt/lists/* 2>/dev/null || true

      - name: Setup Ruby environment
        run: |
          echo "=== Ruby Environment Setup ==="
          echo "System Ruby version: $(ruby -v)"
          echo "System Bundler gems: $(gem list bundler --local)"
          
          # Check if we have a compatible Ruby version available
          echo "Checking available Ruby versions:"
          if command -v ruby3.2 >/dev/null 2>&1; then
            echo "âœ“ Ruby 3.2 is available"
            # Switch to Ruby 3.2 for better compatibility
            sudo update-alternatives --set ruby /usr/bin/ruby3.2
            sudo update-alternatives --set gem /usr/bin/gem3.2
            echo "Switched to Ruby: $(ruby -v)"
          elif command -v ruby3.1 >/dev/null 2>&1; then
            echo "âœ“ Ruby 3.1 is available"
            sudo update-alternatives --set ruby /usr/bin/ruby3.1
            sudo update-alternatives --set gem /usr/bin/gem3.1
            echo "Switched to Ruby: $(ruby -v)"
          else
            echo "âš  No newer Ruby versions available via update-alternatives, attempting to install Ruby 3.2.8 with rbenv..."
            
            # Install rbenv if not present
            if [ ! -d "$HOME/.rbenv" ]; then
              echo "Installing rbenv..."
              git clone https://github.com/rbenv/rbenv.git $HOME/.rbenv
              
              # Install ruby-build plugin
              git clone https://github.com/rbenv/ruby-build.git $HOME/.rbenv/plugins/ruby-build
              
              # Add rbenv to PATH
              export PATH="$HOME/.rbenv/bin:$PATH"
            else
              export PATH="$HOME/.rbenv/bin:$PATH"
            fi
            
            # Reinitialize rbenv
            eval "$(rbenv init -)"
            
            # Install Ruby 3.2.8 if not already installed
            if ! rbenv versions --bare | grep -q "^3\.2\.8$"; then
              echo "Installing Ruby 3.2.8..."
              rbenv install 3.2.8
            fi
            
            # Set Ruby 3.2.8 as the global version
            rbenv global 3.2.8
            eval "$(rbenv init -)"
            
            echo "Set Ruby version to: $(ruby -v)"
          fi
          
          # Get current Ruby version after potential switch
          CURRENT_RUBY=$(ruby -v | cut -d' ' -f2 | cut -d'p' -f1)
          CURRENT_MAJOR_MINOR=$(echo "$CURRENT_RUBY" | cut -d'.' -f1,2)
          echo "Current Ruby version: $CURRENT_RUBY (major.minor: $CURRENT_MAJOR_MINOR)"
          
          # Determine compatible bundler version based on Ruby version
          # Use newer bundler versions that support force_ruby_platform: true from Gemfile
          case "$CURRENT_MAJOR_MINOR" in
            "3.0")
              # Ruby 3.0 needs a newer bundler that supports force_ruby_platform
              BUNDLER_VERSION="2.4.22"  # Supports force_ruby_platform and is compatible with Ruby 3.0
              echo "Using bundler version $BUNDLER_VERSION for Ruby 3.0 compatibility with force_ruby_platform support"
              ;;
            "3.1")
              BUNDLER_VERSION="2.4.22"  # Safe version that supports force_ruby_platform
              echo "Using bundler version $BUNDLER_VERSION for Ruby 3.1 compatibility with force_ruby_platform support"
              ;;
            "3.2")
              BUNDLER_VERSION="2.7.1"   # Latest version for Ruby 3.2+
              echo "Using bundler version $BUNDLER_VERSION for Ruby 3.2+ compatibility"
              ;;
            *)
              BUNDLER_VERSION="2.7.1"  # Latest version that supports force_ruby_platform
              echo "Using fallback bundler version $BUNDLER_VERSION with force_ruby_platform support"
              ;;
          esac
          
          export BUNDLER_VERSION
          echo "Final BUNDLER_VERSION: $BUNDLER_VERSION"
          
          # Create user gem directory if it doesn't exist
          mkdir -p $HOME/.gem/ruby
          
          # Install bundler to user directory using the approach from GitLab CI prepare_bundle.sh
          echo "Installing bundler version $BUNDLER_VERSION to user directory..."
          gem install bundler:$BUNDLER_VERSION --user-install --no-document --force
          
          # Find the correct user gem bin directory - prioritize the main bin directory
          USER_GEM_BIN=""
          
          # First try to find the main user bin directory (not template directories)
          RUBY_VERSION=$(ruby -v | cut -d' ' -f2 | cut -d'.' -f1,2)
          MAIN_USER_BIN="$HOME/.gem/ruby/$RUBY_VERSION.0/bin"
          
          if [ -d "$MAIN_USER_BIN" ] && [ -f "$MAIN_USER_BIN/bundle" ]; then
            USER_GEM_BIN="$MAIN_USER_BIN"
            echo "Found main user gem bin directory: $USER_GEM_BIN"
          else
            # Fallback: search for bin directories but exclude template directories
            USER_GEM_BIN=$(find $HOME/.gem -path "*/bin" -type d -not -path "*/templates/*" -not -path "*/template/*" 2>/dev/null | head -1)
            if [ -n "$USER_GEM_BIN" ] && [ -f "$USER_GEM_BIN/bundle" ]; then
              echo "Found user gem bin directory (fallback search): $USER_GEM_BIN"
            else
              # Last resort: use the main bin directory even if it doesn't exist yet
              USER_GEM_BIN="$MAIN_USER_BIN"
              echo "Using default user gem bin directory: $USER_GEM_BIN"
              mkdir -p "$USER_GEM_BIN"
            fi
          fi
          
          # Add to PATH
          export PATH="$USER_GEM_BIN:$PATH"
          echo "$USER_GEM_BIN" >> $GITHUB_PATH
          
          # Verify installation in the same session
          if command -v bundle >/dev/null 2>&1; then
            INSTALLED_BUNDLER=$(bundle --version 2>/dev/null | head -1)
            echo "âœ“ Bundler successfully installed: $INSTALLED_BUNDLER"
            gem list bundler --local
          else
            echo "âŒ Bundler installation failed - bundle command not found"
            echo "PATH: $PATH"
            echo "Looking for bundle in:"
            echo "Main user bin: $MAIN_USER_BIN"
            echo "Selected user bin: $USER_GEM_BIN"
            ls -la "$MAIN_USER_BIN" 2>/dev/null || echo "Main user bin directory not found or empty"
            find $HOME/.gem -name "bundle" -type f 2>/dev/null || echo "Bundle executable not found"
            echo "Available Ruby: $(ruby -v)"
            echo "Available bundler gems:"
            gem list bundler --local
            exit 1
          fi
          
          echo "Final environment:"
          echo "Ruby: $(ruby -v)"
          echo "Bundler: $(bundle --version 2>/dev/null | head -1)"
          echo "Bundler gems: $(gem list bundler --local)"
          echo "Bundle executable path: $(which bundle)"
          echo "Current PATH: $PATH"

      - name: Install Ruby gems
        run: |
          echo "=== Installing Ruby Gems ==="
          
          # Recalculate BUNDLER_VERSION for consistency (same logic as setup step)
          CURRENT_RUBY=$(ruby -v | cut -d' ' -f2 | cut -d'p' -f1)
          CURRENT_MAJOR_MINOR=$(echo "$CURRENT_RUBY" | cut -d'.' -f1,2)
          case "$CURRENT_MAJOR_MINOR" in
            "3.0") BUNDLER_VERSION="2.4.22" ;;
            "3.1") BUNDLER_VERSION="2.4.22" ;;
            "3.2") BUNDLER_VERSION="2.7.1" ;;
            *) BUNDLER_VERSION="2.4.22" ;;
          esac
          export BUNDLER_VERSION
          echo "Using BUNDLER_VERSION: $BUNDLER_VERSION"
          
          # Use the same improved PATH logic as setup step
          RUBY_VERSION=$(ruby -v | cut -d' ' -f2 | cut -d'.' -f1,2)
          MAIN_USER_BIN="$HOME/.gem/ruby/$RUBY_VERSION.0/bin"
          USER_GEM_BIN="$MAIN_USER_BIN"
          
          # Ensure the directory exists and add to PATH
          mkdir -p "$USER_GEM_BIN"
          export PATH="$USER_GEM_BIN:$PATH"
          
          # Verify bundle is available
          if ! command -v bundle >/dev/null 2>&1; then
            echo "âŒ Bundle command not found in PATH"
            echo "PATH: $PATH"
            echo "Looking in: $USER_GEM_BIN"
            ls -la "$USER_GEM_BIN" 2>/dev/null || echo "Bin directory not found or empty"
            find $HOME/.gem -name "bundle" -type f 2>/dev/null || echo "Bundle executable not found"
            exit 1
          fi
          
          # Configure bundle following GitLab CI approach from prepare_bundle.sh
          bundle config build.ffi --disable-system-libffi
          bundle config set --local path 'vendor/bundle'
          bundle config set --local without 'rubocop'
          bundle config set --local frozen 'true'
          bundle config set --local jobs '${{ env.BUNDLE_JOBS }}'
          bundle config set --local retry '${{ env.BUNDLE_RETRY }}'
          bundle config set --local without 'development test rubocop'
          
          # Clear any existing bundle cache to avoid conflicts
          bundle config unset cache_path 2>/dev/null || true
          rm -rf vendor/bundle 2>/dev/null || true
          
          # Install gems with the same approach as GitLab CI
          echo "Installing gems with bundler..."
          bundle install -j $(nproc)
          
          # Create binstubs
          bundle binstubs --all
          
          echo "âœ“ Gem installation completed successfully"

      - name: Validate build requirements
        run: |
          echo "=== Build Validation ==="
          
          # Recalculate BUNDLER_VERSION for consistency
          CURRENT_RUBY=$(ruby -v | cut -d' ' -f2 | cut -d'p' -f1)
          CURRENT_MAJOR_MINOR=$(echo "$CURRENT_RUBY" | cut -d'.' -f1,2)
          case "$CURRENT_MAJOR_MINOR" in
            "3.0") BUNDLER_VERSION="2.4.22" ;;
            "3.1") BUNDLER_VERSION="2.4.22" ;;
            "3.2") BUNDLER_VERSION="2.7.1" ;;
            *) BUNDLER_VERSION="2.4.22" ;;
          esac
          export BUNDLER_VERSION
          echo "Using BUNDLER_VERSION: $BUNDLER_VERSION"
          
          # Use the same improved PATH logic as setup step
          RUBY_VERSION=$(ruby -v | cut -d' ' -f2 | cut -d'.' -f1,2)
          MAIN_USER_BIN="$HOME/.gem/ruby/$RUBY_VERSION.0/bin"
          USER_GEM_BIN="$MAIN_USER_BIN"
          
          # Ensure the directory exists and add to PATH
          mkdir -p "$USER_GEM_BIN"
          export PATH="$USER_GEM_BIN:$PATH"
          
          # Debug bundler environment
          echo "Bundler environment check:"
          echo "Bundle version: $(bundle --version 2>/dev/null || echo 'NOT FOUND')"
          echo "Bundle executable: $(which bundle 2>/dev/null || echo 'NOT FOUND')"
          echo "Gem environment:"
          gem env 2>/dev/null || echo "Gem environment not available"
          echo "Current PATH: $PATH"
          echo ""
          
          # Check required patch file
          PATCH_FILE="config/patches/gitlab-rails/replace-license-key.patch"
          if [ ! -f "$PATCH_FILE" ]; then
            echo "::error::Critical patch file not found: $PATCH_FILE"
            echo "This patch is required for EE builds"
            exit 1
          else
            echo "âœ“ Patch file verified: $PATCH_FILE"
            ls -lh "$PATCH_FILE"
          fi
          
          # Check GitLab edition
          if [[ "${{ env.ee }}" == "true" ]]; then
            echo "âœ“ Building GitLab Enterprise Edition"
          else
            echo "::warning::Building Community Edition (ee=false)"
          fi
          
          # Display build environment
          echo "\n=== Build Environment ==="
          echo "Target OS: ${{ matrix.os }} (${{ matrix.image }})"
          echo "Ruby version: $(ruby -v | cut -d' ' -f1-2)"
          echo "Bundler version: $(bundle --version | cut -d' ' -f1-2)"
          echo "Build log level: ${{ env.BUILD_LOG_LEVEL }}"
          echo "Debug mode: ${{ env.DEBUG }}"
          
          # Check available disk space
          AVAILABLE_SPACE=$(df . | awk 'NR==2 {print $4}')
          if [ "$AVAILABLE_SPACE" -lt 10485760 ]; then  # Less than 10GB
            echo "::warning::Low disk space available: $(($AVAILABLE_SPACE / 1024 / 1024))MB"
          fi
          
          # Debug Omnibus installation
          echo "\n=== Omnibus Debug Info ==="
          echo "Omnibus version: $(bundle exec omnibus --version 2>/dev/null || echo 'NOT FOUND')"
          echo "Omnibus executable: $(which omnibus 2>/dev/null || echo 'NOT FOUND')"
          echo "Omnibus gem location: $(bundle show omnibus 2>/dev/null || echo 'NOT FOUND')"

      - name: Build GitLab EE packages
        run: |
          # Echo pipeline type like in GitLab CI
          echo "PIPELINE_TYPE detected as BRANCH_BUILD_PIPELINE"
          
          # Recalculate BUNDLER_VERSION for consistency (same logic as setup step)
          CURRENT_RUBY=$(ruby -v | cut -d' ' -f2 | cut -d'p' -f1)
          CURRENT_MAJOR_MINOR=$(echo "$CURRENT_RUBY" | cut -d'.' -f1,2)
          case "$CURRENT_MAJOR_MINOR" in
            "3.0") BUNDLER_VERSION="2.4.22" ;;
            "3.1") BUNDLER_VERSION="2.4.22" ;;
            "3.2") BUNDLER_VERSION="2.7.1" ;;
            *) BUNDLER_VERSION="2.4.22" ;;
          esac
          export BUNDLER_VERSION
          echo "Using BUNDLER_VERSION: $BUNDLER_VERSION"
          
          # Use the same improved PATH logic as setup step
          RUBY_VERSION=$(ruby -v | cut -d' ' -f2 | cut -d'.' -f1,2)
          MAIN_USER_BIN="$HOME/.gem/ruby/$RUBY_VERSION.0/bin"
          USER_GEM_BIN="$MAIN_USER_BIN"
          
          # Ensure the directory exists and add to PATH
          mkdir -p "$USER_GEM_BIN"
          export PATH="$USER_GEM_BIN:$PATH"
          
          # Verify bundle is available
          if ! command -v bundle >/dev/null 2>&1; then
            echo "âŒ Bundle command not found in PATH"
            echo "PATH: $PATH"
            echo "Looking in: $USER_GEM_BIN"
            ls -la "$USER_GEM_BIN" 2>/dev/null || echo "Bin directory not found or empty"
            find $HOME/.gem -name "bundle" -type f 2>/dev/null || echo "Bundle executable not found"
            exit 1
          fi
          
          # Run the same before_script commands as in GitLab CI
          echo $NIGHTLY
          mkdir -p ~/.ssh
          mkdir -p ~/.aws
          mkdir -p cache
          if [ -n "$DEV_GITLAB_SSH_KEY" ]; then
            echo "$DEV_GITLAB_SSH_KEY" > ~/.ssh/id_rsa;
            cp support/known_hosts ~/.ssh/known_hosts;
            chmod -R 0600 ~/.ssh/;
          fi
          bash scripts/ci/prepare_bundle.sh
          if [ -n "$NIGHTLY" ]; then
            export STAGING_REPO=${NIGHTLY_REPO};
            export FIPS_STAGING_REPO=${NIGHTLY_FIPS_REPO};
          fi
          
          # Ensure cache directory exists with proper permissions
          # Create user-owned cache directory
          mkdir -p $HOME/.cache/omnibus
          chmod 755 $HOME/.cache/omnibus
          
          # Also ensure other required directories exist with proper permissions
          mkdir -p $HOME/pkg
          chmod 755 $HOME/pkg
          
          echo "Cache directory: $HOME/.cache/omnibus"
          echo "Package output directory: $HOME/pkg"
          
          # Create temporary omnibus config with explicit cache directory
          TEMP_OMNIBUS_CONFIG="/tmp/omnibus_config.rb"
          cat > "$TEMP_OMNIBUS_CONFIG" << EOF
          cache_dir '$HOME/.cache/omnibus'
          use_s3_caching false
          fetcher_progress_bar false
          build_retries 2
          fetcher_retries 5
          append_timestamp false
          EOF
          
          echo "Created temporary omnibus config: $TEMP_OMNIBUS_CONFIG"
          echo "Config contents:"
          cat "$TEMP_OMNIBUS_CONFIG"
          
          # Build with verbose logging and explicit config file
          bundle exec omnibus \
            --config-file "$TEMP_OMNIBUS_CONFIG" \
            build gitlab \
            --log-level "${{ env.BUILD_LOG_LEVEL }}"
        env:
          ee: "true"
          COMPRESS_XZ: "true"
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
          PKG_DIR: $HOME/pkg
          NIGHTLY: ""

      - name: Package verification and listing
        run: |
          echo "=== Build Summary ==="
          echo "Generated packages in pkg/ directory:"
          ls -la pkg/ 2>/dev/null || echo "No packages directory found"
          
          echo -e "\n=== DEB Packages ==="
          DEB_COUNT=$(find pkg/ -name "*.deb" -type f 2>/dev/null | wc -l)
          if [ "$DEB_COUNT" -gt 0 ]; then
            find pkg/ -name "*.deb" -type f -exec ls -lh {} \;
            echo "Total DEB packages: $DEB_COUNT"
          else
            echo "No DEB packages generated"
          fi
          
          echo -e "\n=== RPM Packages ==="
          RPM_COUNT=$(find pkg/ -name "*.rpm" -type f 2>/dev/null | wc -l)
          if [ "$RPM_COUNT" -gt 0 ]; then
            find pkg/ -name "*.rpm" -type f -exec ls -lh {} \;
            echo "Total RPM packages: $RPM_COUNT"
          else
            echo "No RPM packages generated"
          fi
          
          TOTAL_PACKAGES=$((DEB_COUNT + RPM_COUNT))
          echo -e "\n=== Final Summary ==="
          echo "OS: ${{ matrix.os }}"
          echo "Total packages generated: $TOTAL_PACKAGES"
          if [ "$TOTAL_PACKAGES" -eq 0 ]; then
            echo "::warning::No packages were generated"
          fi

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        if: always()
        continue-on-error: true
        with:
          name: gitlab-ee-${{ matrix.os }}-${{ github.sha }}
          path: |
            pkg/**
            build_facts/**
            omnibus.log
            build.log
          retention-days: ${{ inputs.debug && 7 || 30 }}
          compression-level: 6
          if-no-files-found: warn

      - name: Workflow completion notice
        if: always()
        run: |
          echo "=== Workflow Status ==="
          echo "âœ… Build workflow completed successfully"
          echo "ðŸ“¦ Artifacts have been uploaded"
          echo "âš ï¸  Any permission errors shown below are from runner cleanup and can be ignored"
          echo ""
          echo "Build Summary:"
          echo "- Target OS: ${{ matrix.os }}"
          echo "- Git SHA: ${{ github.sha }}"
          echo "- Build successful: ${{ job.status == 'success' && 'YES' || 'NO' }}"
          
          # Exit with success to prevent runner cleanup errors from failing the job
          exit 0

      - name: Cleanup workspace
        if: always()
        run: |
          echo "=== Cleanup ==="
          # Remove user-owned temporary files to save space
          rm -rf vendor/bundle/ruby/*/cache 2>/dev/null || true
          rm -rf $HOME/.cache/omnibus/* 2>/dev/null || true
          rm -rf tmp/ 2>/dev/null || true
          
          # Clean up user gem cache
          if [ -d "$HOME/.gem" ]; then
            find $HOME/.gem -name "*.gem" -delete 2>/dev/null || true
          fi
          
          # Show final disk usage
          echo "Final disk usage:"
          du -sh . 2>/dev/null || echo "Unable to calculate disk usage"
          df -h . 2>/dev/null || echo "Unable to show filesystem info"
